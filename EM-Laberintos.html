<!doctype html>
<html lang="es">

    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Entrenamiento Mental ‚Ä¢ Laberintos</title>

        <!-- PWA -->
        <link rel="manifest" href="manifest.json">
        <meta name="theme-color" content="#1976d2">

        <style>
            :root {
                --bg1: #dbeafe;
                --bg2: #e0f2fe;
                --card: #ffffff;
                --text: #0f172a;
                --muted: #64748b;
                --accent: #2563eb;
                --ok: #16a34a;
                --warn: #f59e0b;
                --shadow: 0 18px 40px rgba(0, 0, 0, .14);
                --radius: 22px;
                --maxw: 820px;
            }

            * {
                box-sizing: border-box;
                font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
            }

            html {
                -webkit-text-size-adjust: 100%;
            }

            body {
                margin: 0;
                min-height: 100dvh;
                background:
                    radial-gradient(1200px 800px at 10% 10%, var(--bg1) 0%, transparent 60%),
                    radial-gradient(900px 700px at 90% 20%, var(--bg2) 0%, transparent 55%),
                    linear-gradient(145deg, var(--bg1), var(--bg2));
                padding: 18px;
                color: var(--text);
            }

            .app {
                max-width: var(--maxw);
                margin: 0 auto;
            }

            .header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 12px;
                padding: 14px 16px;
                border-radius: 18px;
                background: rgba(255, 255, 255, .75);
                backdrop-filter: blur(10px);
                box-shadow: var(--shadow);
            }

            .brand {
                display: flex;
                align-items: center;
                gap: 10px;
                cursor: pointer;
                user-select: none;
                text-decoration: none;
                color: inherit;
            }

            .logo {
                width: 42px;
                height: 42px;
                border-radius: 14px;
                display: grid;
                place-items: center;
                background: linear-gradient(135deg, var(--accent), #38bdf8);
                color: #fff;
                font-size: 20px;
                font-weight: 800;
                box-shadow: 0 10px 22px rgba(37, 99, 235, .28);
            }

            .titles .t1 {
                font-weight: 900;
                line-height: 1.1;
                font-size: 15px;
            }

            .titles .t2 {
                font-size: 12px;
                color: var(--muted);
                margin-top: 2px;
            }

            .navbtns {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                justify-content: flex-end;
            }

            .btn {
                border: 0;
                cursor: pointer;
                padding: 10px 12px;
                border-radius: 14px;
                font-weight: 700;
                background: #fff;
                color: var(--text);
                box-shadow: 0 10px 20px rgba(0, 0, 0, .10);
                transition: transform .08s ease;
                text-decoration: none;
                display: inline-flex;
                align-items: center;
                gap: 8px;
            }

            .btn:active {
                transform: translateY(1px);
            }

            .btn.primary {
                background: linear-gradient(135deg, var(--accent), #38bdf8);
                color: #fff;
                box-shadow: 0 14px 26px rgba(37, 99, 235, .26);
            }

            .btn.ok {
                background: linear-gradient(135deg, var(--ok), #22c55e);
                color: #fff;
            }

            .btn.ghost {
                background: rgba(255, 255, 255, .65);
            }

            .grid {
                display: grid;
                grid-template-columns: 1fr;
                gap: 14px;
                margin-top: 14px;
            }


            @media (max-width: 860px) {
                .grid {
                    grid-template-columns: 1fr;
                }
            }

            .card {
                background: rgba(255, 255, 255, .78);
                backdrop-filter: blur(10px);
                border-radius: var(--radius);
                box-shadow: var(--shadow);
                padding: 16px;
            }

            .h1 {
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 10px;
                margin-bottom: 10px;
            }

            .h1 h1 {
                margin: 0;
                font-size: 18px;
                letter-spacing: .2px;
            }

            .sub {
                margin: 0;
                color: var(--muted);
                font-size: 13px;
                line-height: 1.45;
            }

            .controls {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                align-items: center;
                margin-top: 12px;
            }

            select {
                border: 0;
                background: #fff;
                border-radius: 14px;
                padding: 10px 12px;
                font-weight: 700;
                box-shadow: 0 10px 20px rgba(0, 0, 0, .10);
                cursor: pointer;
            }

            .stat {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                margin-top: 12px;
            }

            .pill {
                background: rgba(255, 255, 255, .75);
                border-radius: 999px;
                padding: 8px 10px;
                font-size: 12px;
                color: var(--muted);
                box-shadow: 0 10px 20px rgba(0, 0, 0, .08);
            }

            .canvasWrap {
                display: grid;
                place-items: center;
                padding: 10px;
                border-radius: 18px;
                background: rgba(255, 255, 255, .55);
                box-shadow: inset 0 0 0 1px rgba(15, 23, 42, .06);
                margin-top: 12px;
            }

            canvas {
                width: 100%;
                max-width: 640px;
                aspect-ratio: 1 / 1;
                /* siempre cuadrado */
                height: auto;
                border-radius: 14px;
                background: #fff;
                box-shadow: 0 12px 26px rgba(0, 0, 0, .12);
                touch-action: none;
            }

            .pad {
                display: grid;
                gap: 10px;
                justify-items: center;
                margin-top: 14px;
            }

            .padRow {
                display: flex;
                gap: 10px;
            }

            .pad .btn {
                min-width: 64px;
                justify-content: center;
            }

            .hint {
                margin-top: 10px;
                font-size: 13px;
                color: var(--muted);
                line-height: 1.5;
            }

            .note {
                margin-top: 10px;
                font-size: 12px;
                color: var(--muted);
            }

            @media (max-width: 480px) {

                body {
                    padding: 12px;
                }

                .header {
                    flex-direction: column;
                    align-items: flex-start;
                    gap: 10px;
                }

                .navbtns {
                    width: 100%;
                    justify-content: space-between;
                }

                .btn {
                    padding: 10px 14px;
                    font-size: 14px;
                }

                .h1 h1 {
                    font-size: 17px;
                }

                .sub {
                    font-size: 13px;
                }

                .pad .btn {
                    min-width: 56px;
                    font-size: 18px;
                }
            }

            @media (min-width: 481px) and (max-width: 900px) {

                .app {
                    max-width: 720px;
                }

                canvas {
                    max-width: 560px;
                }
            }

            @media (min-width: 1200px) {

                .app {
                    max-width: 960px;
                }

                canvas {
                    max-width: 700px;
                }

                .h1 h1 {
                    font-size: 20px;
                }
            }
        </style>
    </head>

    <body>
        <div class="app">

            <!-- Encabezado -->
            <header class="header">
                <a class="brand" href="index.html" title="Volver al inicio">
                    <div class="logo">MK</div>
                    <div class="titles">
                        <div class="t1">Entrenamiento Mental</div>
                        <div class="t2">Laberintos ‚Ä¢ Encuentra la salida</div>
                    </div>
                </a>

                <div class="navbtns">
                    <a class="btn ghost" href="EM-Menu.html">üìö Men√∫</a>
                    <a class="btn" href="index.html">üè† Inicio</a>
                </div>
            </header>

            <div class="grid">
                <!-- Juego -->
                <section class="card">
                    <div class="h1">
                        <h1>üó∫Ô∏è Laberinto</h1>
                        <button id="btnNew" class="btn primary">‚ú® Nuevo</button>
                    </div>
                    <p class="sub">
                        Mueve al jugador desde <b>Inicio</b> hasta <b>Salida</b>. Usa las teclas
                        <b>‚Üê ‚Üë ‚Üí ‚Üì</b> o los botones. Puedes pedir una pista con ‚ÄúResolver‚Äù.
                    </p>

                    <div class="controls">
                        <label style="display:flex; gap:8px; align-items:center;">
                            <span style="font-weight:800; color:var(--muted); font-size:12px;">Tama√±o</span>
                            <select id="size">
                                <option value="11">11√ó11 (f√°cil)</option>
                                <option value="15" selected>15√ó15 (medio)</option>
                                <option value="21">21√ó21 (dif√≠cil)</option>
                                <option value="25">25√ó25 (experto)</option>
                            </select>
                        </label>

                        <button id="btnSolve" class="btn ok">‚úÖ Resolver</button>
                        <button id="btnClear" class="btn">üßº Borrar ruta</button>
                    </div>

                    <div class="stat">
                        <div class="pill" id="pMoves">Movimientos: 0</div>
                        <div class="pill" id="pTime">Tiempo: 00:00</div>
                        <div class="pill" id="pBest">Mejor: ‚Äî</div>
                    </div>

                    <div class="canvasWrap">
                        <canvas id="maze"></canvas>

                    </div>

                    <div class="pad" aria-label="Controles">
                        <button class="btn" data-move="U">‚¨ÜÔ∏è</button>
                        <div class="padRow">
                            <button class="btn" data-move="L">‚¨ÖÔ∏è</button>
                            <button class="btn" data-move="D">‚¨áÔ∏è</button>
                            <button class="btn" data-move="R">‚û°Ô∏è</button>
                        </div>
                    </div>

                    <div class="hint" id="hint">
                        Consejo: primero busca un camino ‚Äúmacro‚Äù (zonas), luego ajusta con pasos cortos.
                    </div>
                    <div class="note">
                        *Plantilla lista para ampliar: niveles, monedas/XP, bloqueos, etc.
                    </div>
                </section>

                <!-- Panel derecho -->

            </div>
        </div>

        <script>
            // =========================
            //  Laberinto (Plantilla)
            //  - Generaci√≥n: DFS (perfect maze)
            //  - Soluci√≥n: BFS (camino m√°s corto)
            //  - Dibujo: Canvas
            // =========================

            const canvas = document.getElementById("maze");
            const ctx = canvas.getContext("2d");

            const $ = (id) => document.getElementById(id);

            const elMoves = $("pMoves");
            const elTime = $("pTime");
            const elBest = $("pBest");
            const elSize = $("size");
            const btnNew = $("btnNew");
            const btnSolve = $("btnSolve");
            const btnClear = $("btnClear");

            const pads = [...document.querySelectorAll("[data-move]")];

            // Estado
            let N = 15;                 // tama√±o (celdas)
            let grid = [];              // 0 = pared, 1 = camino
            let cellSize = 0;

            let player = { r: 1, c: 1 };
            let start = { r: 1, c: 1 };
            let exit = { r: 0, c: 0 };

            let moves = 0;
            let seconds = 0;
            let timer = null;

            let breadcrumbs = [];       // camino del jugador
            let solvedPath = null;      // camino soluci√≥n

            // Best por tama√±o
            const BEST_KEY = "EM_LAB_BEST";

            function pad2(n) { return String(n).padStart(2, "0"); }

            function startTimer() {
                stopTimer();
                timer = setInterval(() => {
                    seconds++;
                    elTime.textContent = `Tiempo: ${pad2(Math.floor(seconds / 60))}:${pad2(seconds % 60)}`;
                }, 1000);
            }

            function stopTimer() {
                if (timer) clearInterval(timer);
                timer = null;
            }

            function resetStats() {
                moves = 0;
                seconds = 0;
                elMoves.textContent = "Movimientos: 0";
                elTime.textContent = "Tiempo: 00:00";
            }

            function loadBest() {
                try {
                    const data = JSON.parse(localStorage.getItem(BEST_KEY) || "{}");
                    const best = data[String(N)];
                    elBest.textContent = best ? `Mejor: ${best.moves} mov ‚Ä¢ ${best.time}` : "Mejor: ‚Äî";
                } catch {
                    elBest.textContent = "Mejor: ‚Äî";
                }
            }

            function saveBestIfNeeded() {
                try {
                    const data = JSON.parse(localStorage.getItem(BEST_KEY) || "{}");
                    const key = String(N);
                    const current = { moves, time: `${pad2(Math.floor(seconds / 60))}:${pad2(seconds % 60)}` };
                    const prev = data[key];

                    const better =
                        !prev ||
                        current.moves < prev.moves ||
                        (current.moves === prev.moves && timeToSec(current.time) < timeToSec(prev.time));

                    if (better) {
                        data[key] = current;
                        localStorage.setItem(BEST_KEY, JSON.stringify(data));
                        loadBest();
                    }
                } catch { }
            }

            function timeToSec(t) {
                const [m, s] = t.split(":").map(Number);
                return m * 60 + s;
            }

            // ----- Generaci√≥n de laberinto -----
            // Usamos una malla de (2N+1) para paredes y pasillos:
            // - celdas "habitables" en posiciones impares
            // - paredes en pares
            function makeEmptyGrid(n) {
                const H = 2 * n + 1;
                const W = 2 * n + 1;
                const g = Array.from({ length: H }, () => Array(W).fill(0));
                return g;
            }

            function inside(n, r, c) {
                return r >= 0 && c >= 0 && r < n && c < n;
            }

            function shuffle(arr) {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            // Perfect maze: DFS sobre celdas (n x n)
            function generateMaze(n) {
                const g = makeEmptyGrid(n);

                // Marcar celdas como caminos
                for (let r = 0; r < n; r++) {
                    for (let c = 0; c < n; c++) {
                        g[2 * r + 1][2 * c + 1] = 1;
                    }
                }

                const visited = Array.from({ length: n }, () => Array(n).fill(false));
                const stack = [{ r: 0, c: 0 }];
                visited[0][0] = true;

                const dirs = [
                    { dr: -1, dc: 0 },
                    { dr: 1, dc: 0 },
                    { dr: 0, dc: -1 },
                    { dr: 0, dc: 1 }
                ];

                while (stack.length) {
                    const cur = stack[stack.length - 1];
                    const options = [];

                    for (const d of dirs) {
                        const nr = cur.r + d.dr, nc = cur.c + d.dc;
                        if (inside(n, nr, nc) && !visited[nr][nc]) {
                            options.push({ nr, nc, dr: d.dr, dc: d.dc });
                        }
                    }

                    if (!options.length) {
                        stack.pop();
                        continue;
                    }

                    const pick = shuffle(options)[0];
                    visited[pick.nr][pick.nc] = true;

                    // Abrir pared entre cur y pick en la grilla grande
                    const gr = 2 * cur.r + 1;
                    const gc = 2 * cur.c + 1;
                    const wr = gr + pick.dr;
                    const wc = gc + pick.dc;
                    g[wr][wc] = 1;

                    stack.push({ r: pick.nr, c: pick.nc });
                }

                return g;
            }

            // ----- Soluci√≥n (BFS) sobre la grilla grande -----
            function bfsPath(g, startRC, endRC) {
                const H = g.length, W = g[0].length;
                const q = [];
                const prev = Array.from({ length: H }, () => Array(W).fill(null));
                const seen = Array.from({ length: H }, () => Array(W).fill(false));

                const s = startRC;
                const e = endRC;

                q.push(s);
                seen[s.r][s.c] = true;

                const dirs = [
                    { dr: -1, dc: 0 },
                    { dr: 1, dc: 0 },
                    { dr: 0, dc: -1 },
                    { dr: 0, dc: 1 }
                ];

                while (q.length) {
                    const cur = q.shift();
                    if (cur.r === e.r && cur.c === e.c) break;

                    for (const d of dirs) {
                        const nr = cur.r + d.dr, nc = cur.c + d.dc;
                        if (nr < 0 || nc < 0 || nr >= H || nc >= W) continue;
                        if (seen[nr][nc]) continue;
                        if (g[nr][nc] !== 1) continue;

                        seen[nr][nc] = true;
                        prev[nr][nc] = cur;
                        q.push({ r: nr, c: nc });
                    }
                }

                if (!seen[e.r][e.c]) return null;

                // reconstruir
                const path = [];
                let cur = e;
                while (cur) {
                    path.push(cur);
                    cur = prev[cur.r][cur.c];
                }
                path.reverse();
                return path;
            }

            // ----- Dibujo -----
            function computeCellSize() {
                const H = grid.length;
                cellSize = Math.floor(canvas.width / H);
            }

            function draw() {
                const H = grid.length;
                computeCellSize();
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Fondo
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Paredes
                ctx.fillStyle = "#0f172a";
                for (let r = 0; r < H; r++) {
                    for (let c = 0; c < H; c++) {
                        if (grid[r][c] === 0) {
                            ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
                        }
                    }
                }

                // Ruta del jugador (breadcrumbs)
                if (breadcrumbs.length) {
                    ctx.fillStyle = "rgba(37, 99, 235, .18)";
                    for (const p of breadcrumbs) {
                        ctx.fillRect(p.c * cellSize, p.r * cellSize, cellSize, cellSize);
                    }
                }

                // Soluci√≥n (si existe)
                if (solvedPath && solvedPath.length) {
                    ctx.fillStyle = "rgba(22, 163, 74, .20)";
                    for (const p of solvedPath) {
                        ctx.fillRect(p.c * cellSize, p.r * cellSize, cellSize, cellSize);
                    }
                }

                // Inicio y salida
                ctx.fillStyle = "rgba(245, 158, 11, .35)";
                ctx.fillRect(start.c * cellSize, start.r * cellSize, cellSize, cellSize);

                ctx.fillStyle = "rgba(16, 185, 129, .35)";
                ctx.fillRect(exit.c * cellSize, exit.r * cellSize, cellSize, cellSize);

                // Jugador
                const x = player.c * cellSize + cellSize / 2;
                const y = player.r * cellSize + cellSize / 2;
                ctx.beginPath();
                ctx.fillStyle = "#2563eb";
                ctx.arc(x, y, Math.max(6, cellSize * 0.28), 0, Math.PI * 2);
                ctx.fill();

                // borde jugador
                ctx.lineWidth = Math.max(2, cellSize * 0.06);
                ctx.strokeStyle = "rgba(15, 23, 42, .25)";
                ctx.stroke();
            }

            function setSizeFromSelect() {
                N = parseInt(elSize.value, 10);
                localStorage.setItem("EM_LAB_SIZE", String(N));
            }

            function restoreSize() {
                const saved = localStorage.getItem("EM_LAB_SIZE");
                if (saved) {
                    elSize.value = saved;
                    N = parseInt(saved, 10);
                }
            }

            // ===== Canvas responsive =====
            function resizeCanvas() {
                if (!canvas || !canvas.parentElement) return;
                if (!grid || !grid.length) return;

                const parentWidth = canvas.parentElement.clientWidth;
                const size = Math.min(parentWidth, 700);

                canvas.width = size;
                canvas.height = size;

                draw();
            }


            function newMaze() {
                setSizeFromSelect();
                grid = generateMaze(N);

                // Inicio y salida en grilla grande (impares)
                start = { r: 1, c: 1 };
                exit = { r: grid.length - 2, c: grid.length - 2 };

                player = { ...start };
                moves = 0;
                seconds = 0;
                breadcrumbs = [{ ...player }];
                solvedPath = null;

                resetStats();
                loadBest();
                startTimer();
                draw();
                $("hint").textContent = "Tip: si te pierdes, vuelve a un cruce y prueba la otra rama.";
            }

            function canMoveTo(r, c) {
                return grid[r] && grid[r][c] === 1;
            }

            function movePlayer(dir) {
                const map = {
                    U: { dr: -1, dc: 0 },
                    D: { dr: 1, dc: 0 },
                    L: { dr: 0, dc: -1 },
                    R: { dr: 0, dc: 1 }
                };
                const d = map[dir];
                if (!d) return;

                const nr = player.r + d.dr;
                const nc = player.c + d.dc;

                if (!canMoveTo(nr, nc)) return;

                player = { r: nr, c: nc };
                breadcrumbs.push({ ...player });

                moves++;
                elMoves.textContent = `Movimientos: ${moves}`;

                // Si llega
                if (player.r === exit.r && player.c === exit.c) {
                    stopTimer();
                    saveBestIfNeeded();
                    $("hint").textContent = "üèÅ ¬°Llegaste! Presiona ‚ÄúNuevo‚Äù para otro laberinto.";
                }

                draw();
            }

            function solve() {
                solvedPath = bfsPath(grid, start, exit);
                draw();
                $("hint").textContent = solvedPath
                    ? "‚úÖ Ruta sugerida mostrada en verde. Intenta memorizarla y repetir sin ayuda."
                    : "No se encontr√≥ soluci√≥n (raro). Prueba ‚ÄúNuevo‚Äù.";
            }

            function clearRoute() {
                breadcrumbs = [{ ...start }];
                player = { ...start };
                solvedPath = null;
                moves = 0;
                seconds = 0;
                resetStats();
                startTimer();
                draw();
                $("hint").textContent = "Ruta borrada. Vuelve a intentarlo desde el inicio.";
            }

            // ===== Eventos =====
            btnNew.addEventListener("click", newMaze);
            btnSolve.addEventListener("click", solve);
            btnClear.addEventListener("click", clearRoute);
            elSize.addEventListener("change", newMaze);

            pads.forEach(b => b.addEventListener("click", () => movePlayer(b.dataset.move)));

            window.addEventListener("keydown", (e) => {


                const keyMap = {
                    ArrowUp: "U",
                    ArrowDown: "D",
                    ArrowLeft: "L",
                    ArrowRight: "R",
                    w: "U", s: "D", a: "L", d: "R"
                };
                const dir = keyMap[e.key];
                if (dir) {
                    e.preventDefault();
                    movePlayer(dir);
                }
            }, { passive: false });

            // Redimensionar canvas cuando cambia el tama√±o de la pantalla
            window.addEventListener("resize", () => {
                resizeCanvas();
            });

            // Redimensionar canvas al rotar el celular
            window.addEventListener("orientationchange", () => {
                setTimeout(resizeCanvas, 200);
            });


            // Canvas click/tap: mueve hacia donde tocas (aprox)
            canvas.addEventListener("pointerdown", (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Convertir a celda
                const H = grid.length;
                const cs = rect.width / H;
                const tc = Math.floor(x / cs);
                const tr = Math.floor(y / cs);

                // mover 1 paso en la direcci√≥n predominante
                const dr = tr - player.r;
                const dc = tc - player.c;

                if (Math.abs(dc) > Math.abs(dr)) {
                    movePlayer(dc > 0 ? "R" : "L");
                } else {
                    movePlayer(dr > 0 ? "D" : "U");
                }
            });

            // Inicial
            // Inicial
            restoreSize();
            newMaze();        // primero crea el laberinto
            resizeCanvas();  // luego ajusta el canvas

        </script>

        <script>
            // Registrar Service Worker (PWA)
            if ("serviceWorker" in navigator) {
                window.addEventListener("load", () => {
                    navigator.serviceWorker.register("./service-worker.js").catch(() => { });
                });
            }
        </script>
    </body>

</html>
